import PDFDocument from 'pdfkit';
import * as ExcelJS from 'exceljs';
import { promises as fs } from 'fs';
import path from 'path';
import { v4 as uuidv4 } from 'uuid';
import { logger } from '../utils/logger';
import { createWriteStream } from 'fs';

export interface ReportMetadata {
  id: string;
  name: string;
  description: string;
  type: 'pdf' | 'json' | 'xlsx' | 'txt';
  size: number;
  agent: string;
  useCaseId: string;
  workflowId?: string;
  createdAt: Date;
  storagePath: string;
  downloadUrl: string;
}

export interface ReportContent {
  title: string;
  subtitle?: string;
  sections: ReportSection[];
  metadata?: Record<string, any>;
  data?: any[];
}

export interface ReportSection {
  heading: string;
  content: string | any[];
  type: 'text' | 'table' | 'list' | 'json';
}

class ReportService {
  private readonly reportsDir = path.join(process.cwd(), 'reports');
  private readonly publicReportsDir = path.join(process.cwd(), 'public', 'reports');

  constructor() {
    this.ensureDirectories();
  }

  private async ensureDirectories() {
    try {
      await fs.mkdir(this.reportsDir, { recursive: true });
      await fs.mkdir(this.publicReportsDir, { recursive: true });
    } catch (error) {
      logger.error('Failed to create report directories:', error);
    }
  }

  /**
   * Generate a PDF report using pdfkit
   */
  async generatePDFReport(content: ReportContent, metadata: Omit<ReportMetadata, 'id' | 'size' | 'createdAt' | 'storagePath' | 'downloadUrl'>): Promise<ReportMetadata> {
    return new Promise((resolve, reject) => {
      try {
        const reportId = uuidv4();
        const filename = `${metadata.name.replace(/[^a-z0-9]/gi, '_')}_${reportId}.pdf`;
        const storagePath = path.join(this.reportsDir, filename);
        const publicPath = path.join(this.publicReportsDir, filename);

        // Create PDF document
        const doc = new PDFDocument({
          size: 'A4',
          margins: {
            top: 50,
            bottom: 50,
            left: 50,
            right: 50
          }
        });

        // Pipe to file
        const stream = createWriteStream(storagePath);
        doc.pipe(stream);

        // Also save to public directory
        const publicStream = createWriteStream(publicPath);
        doc.pipe(publicStream);

        // Title
        doc.fontSize(24)
           .font('Helvetica-Bold')
           .text(content.title, { align: 'center' });
        doc.moveDown();

        // Subtitle
        if (content.subtitle) {
          doc.fontSize(14)
             .font('Helvetica')
             .fillColor('#666666')
             .text(content.subtitle, { align: 'center' });
          doc.moveDown();
        }

        // Metadata
        doc.fontSize(10)
           .fillColor('#999999')
           .text(`Generated by: ${metadata.agent}`, { align: 'left' })
           .text(`Date: ${new Date().toLocaleString()}`, { align: 'left' })
           .text(`Use Case: ${metadata.useCaseId}`, { align: 'left' });
        doc.moveDown(2);

        // Reset color
        doc.fillColor('#000000');

        // Content sections
        for (const section of content.sections) {
          // Section heading
          doc.fontSize(16)
             .font('Helvetica-Bold')
             .text(section.heading);
          doc.moveDown(0.5);

          // Section content
          doc.fontSize(11)
             .font('Helvetica');

          if (section.type === 'text') {
            doc.text(section.content as string, {
              align: 'justify',
              lineGap: 2
            });
          } else if (section.type === 'list') {
            const items = section.content as string[];
            items.forEach(item => {
              doc.text(`• ${item}`, {
                indent: 20,
                lineGap: 2
              });
            });
          } else if (section.type === 'table') {
            // Simple table rendering
            const tableData = section.content as any[];
            if (tableData.length > 0) {
              const headers = Object.keys(tableData[0]);
              
              // Table headers
              doc.font('Helvetica-Bold');
              let x = doc.x;
              const y = doc.y;
              const columnWidth = (doc.page.width - 100) / headers.length;
              
              headers.forEach((header, i) => {
                doc.text(header, x + (i * columnWidth), y, {
                  width: columnWidth,
                  align: 'left'
                });
              });
              
              doc.moveDown();
              doc.font('Helvetica');
              
              // Table rows
              tableData.forEach(row => {
                const rowY = doc.y;
                headers.forEach((header, i) => {
                  doc.text(String(row[header] || ''), x + (i * columnWidth), rowY, {
                    width: columnWidth,
                    align: 'left'
                  });
                });
                doc.moveDown(0.5);
              });
            }
          } else if (section.type === 'json') {
            doc.fontSize(10)
               .font('Courier')
               .text(JSON.stringify(section.content, null, 2), {
                 lineGap: 1
               });
            doc.font('Helvetica');
          }
          
          doc.moveDown(2);
        }

        // Finalize PDF
        doc.end();

        stream.on('finish', async () => {
          try {
            const stats = await fs.stat(storagePath);
            const reportMetadata: ReportMetadata = {
              id: reportId,
              ...metadata,
              size: stats.size,
              createdAt: new Date(),
              storagePath,
              downloadUrl: `/reports/${filename}`,
            };

            logger.info('PDF report generated:', reportMetadata);
            resolve(reportMetadata);
          } catch (error) {
            reject(error);
          }
        });

        stream.on('error', reject);
      } catch (error) {
        logger.error('Failed to generate PDF report:', error);
        reject(error);
      }
    });
  }

  /**
   * Generate a JSON report
   */
  async generateJSONReport(data: any, metadata: Omit<ReportMetadata, 'id' | 'size' | 'createdAt' | 'storagePath' | 'downloadUrl'>): Promise<ReportMetadata> {
    try {
      const reportId = uuidv4();
      const filename = `${metadata.name.replace(/[^a-z0-9]/gi, '_')}_${reportId}.json`;
      const storagePath = path.join(this.reportsDir, filename);
      const publicPath = path.join(this.publicReportsDir, filename);

      // Create comprehensive JSON report
      const reportData = {
        metadata: {
          id: reportId,
          name: metadata.name,
          description: metadata.description,
          generatedBy: metadata.agent,
          useCase: metadata.useCaseId,
          workflowId: metadata.workflowId,
          generatedAt: new Date().toISOString(),
          version: '1.0'
        },
        summary: {
          totalRecords: Array.isArray(data) ? data.length : 1,
          dataType: Array.isArray(data) ? 'array' : typeof data
        },
        data: data
      };

      const jsonContent = JSON.stringify(reportData, null, 2);
      await fs.writeFile(storagePath, jsonContent);
      await fs.writeFile(publicPath, jsonContent);

      const reportMetadata: ReportMetadata = {
        id: reportId,
        ...metadata,
        size: Buffer.byteLength(jsonContent),
        createdAt: new Date(),
        storagePath,
        downloadUrl: `/reports/${filename}`,
      };

      logger.info('JSON report generated:', reportMetadata);
      return reportMetadata;
    } catch (error) {
      logger.error('Failed to generate JSON report:', error);
      throw error;
    }
  }

  /**
   * Generate an Excel report using ExcelJS
   */
  async generateXLSXReport(data: any[] | Record<string, any[]>, metadata: Omit<ReportMetadata, 'id' | 'size' | 'createdAt' | 'storagePath' | 'downloadUrl'>): Promise<ReportMetadata> {
    try {
      const reportId = uuidv4();
      const filename = `${metadata.name.replace(/[^a-z0-9]/gi, '_')}_${reportId}.xlsx`;
      const storagePath = path.join(this.reportsDir, filename);
      const publicPath = path.join(this.publicReportsDir, filename);

      // Create workbook
      const workbook = new ExcelJS.Workbook();
      workbook.creator = metadata.agent;
      workbook.created = new Date();
      workbook.modified = new Date();

      // Add metadata sheet
      const metadataSheet = workbook.addWorksheet('Report Information');
      metadataSheet.columns = [
        { header: 'Property', key: 'property', width: 30 },
        { header: 'Value', key: 'value', width: 50 }
      ];

      metadataSheet.addRows([
        { property: 'Report Name', value: metadata.name },
        { property: 'Description', value: metadata.description },
        { property: 'Generated By', value: metadata.agent },
        { property: 'Use Case', value: metadata.useCaseId },
        { property: 'Workflow ID', value: metadata.workflowId || 'N/A' },
        { property: 'Generated At', value: new Date().toISOString() },
      ]);

      // Style the metadata sheet
      metadataSheet.getRow(1).font = { bold: true };
      metadataSheet.getRow(1).fill = {
        type: 'pattern',
        pattern: 'solid',
        fgColor: { argb: 'FFE0E0E0' }
      };

      // Add data sheets
      if (Array.isArray(data)) {
        // Single data array
        const dataSheet = workbook.addWorksheet('Data');
        
        if (data.length > 0 && typeof data[0] === 'object') {
          // Set columns from first object
          const columns = Object.keys(data[0]).map(key => ({
            header: key,
            key: key,
            width: 20
          }));
          dataSheet.columns = columns;
          
          // Add data
          dataSheet.addRows(data);
          
          // Style header row
          dataSheet.getRow(1).font = { bold: true };
          dataSheet.getRow(1).fill = {
            type: 'pattern',
            pattern: 'solid',
            fgColor: { argb: 'FF4472C4' }
          };
          dataSheet.getRow(1).font = { color: { argb: 'FFFFFFFF' } };
          
          // Add filters
          dataSheet.autoFilter = {
            from: 'A1',
            to: `${String.fromCharCode(64 + columns.length)}1`
          };
        }
      } else if (typeof data === 'object') {
        // Multiple data arrays (sheets)
        Object.entries(data).forEach(([sheetName, sheetData]) => {
          if (Array.isArray(sheetData) && sheetData.length > 0) {
            const sheet = workbook.addWorksheet(sheetName);
            
            const columns = Object.keys(sheetData[0]).map(key => ({
              header: key,
              key: key,
              width: 20
            }));
            sheet.columns = columns;
            
            sheet.addRows(sheetData);
            
            // Style header row
            sheet.getRow(1).font = { bold: true };
            sheet.getRow(1).fill = {
              type: 'pattern',
              pattern: 'solid',
              fgColor: { argb: 'FF4472C4' }
            };
            sheet.getRow(1).font = { color: { argb: 'FFFFFFFF' } };
            
            // Add filters
            sheet.autoFilter = {
              from: 'A1',
              to: `${String.fromCharCode(64 + columns.length)}1`
            };
          }
        });
      }

      // Write file
      await workbook.xlsx.writeFile(storagePath);
      await workbook.xlsx.writeFile(publicPath);

      const stats = await fs.stat(storagePath);
      const reportMetadata: ReportMetadata = {
        id: reportId,
        ...metadata,
        size: stats.size,
        createdAt: new Date(),
        storagePath,
        downloadUrl: `/reports/${filename}`,
      };

      logger.info('XLSX report generated:', reportMetadata);
      return reportMetadata;
    } catch (error) {
      logger.error('Failed to generate XLSX report:', error);
      throw error;
    }
  }

  /**
   * Generate a text report
   */
  async generateTXTReport(content: string | ReportContent, metadata: Omit<ReportMetadata, 'id' | 'size' | 'createdAt' | 'storagePath' | 'downloadUrl'>): Promise<ReportMetadata> {
    try {
      const reportId = uuidv4();
      const filename = `${metadata.name.replace(/[^a-z0-9]/gi, '_')}_${reportId}.txt`;
      const storagePath = path.join(this.reportsDir, filename);
      const publicPath = path.join(this.publicReportsDir, filename);

      let textContent: string;
      if (typeof content === 'string') {
        // Add header to plain text content
        textContent = `${'='.repeat(80)}\n`;
        textContent += `REPORT: ${metadata.name}\n`;
        textContent += `${'='.repeat(80)}\n\n`;
        textContent += `Description: ${metadata.description}\n`;
        textContent += `Generated by: ${metadata.agent}\n`;
        textContent += `Use Case: ${metadata.useCaseId}\n`;
        textContent += `Date: ${new Date().toLocaleString()}\n`;
        textContent += `${'='.repeat(80)}\n\n`;
        textContent += content;
      } else {
        // Format ReportContent as text
        textContent = this.formatReportContentAsText(content, metadata);
      }

      await fs.writeFile(storagePath, textContent, 'utf8');
      await fs.writeFile(publicPath, textContent, 'utf8');

      const reportMetadata: ReportMetadata = {
        id: reportId,
        ...metadata,
        size: Buffer.byteLength(textContent),
        createdAt: new Date(),
        storagePath,
        downloadUrl: `/reports/${filename}`,
      };

      logger.info('TXT report generated:', reportMetadata);
      return reportMetadata;
    } catch (error) {
      logger.error('Failed to generate TXT report:', error);
      throw error;
    }
  }

  /**
   * Get report by ID
   */
  async getReport(reportId: string): Promise<ReportMetadata | null> {
    try {
      const files = await fs.readdir(this.reportsDir);
      const reportFile = files.find(f => f.includes(reportId));
      if (reportFile) {
        const stats = await fs.stat(path.join(this.reportsDir, reportFile));
        return {
          id: reportId,
          name: reportFile.replace(`_${reportId}`, '').replace(/\.[^.]+$/, ''),
          description: 'Report file',
          type: reportFile.endsWith('.pdf') ? 'pdf' : 
                reportFile.endsWith('.json') ? 'json' :
                reportFile.endsWith('.xlsx') ? 'xlsx' : 'txt',
          size: stats.size,
          agent: 'Unknown',
          useCaseId: 'Unknown',
          createdAt: stats.birthtime,
          storagePath: path.join(this.reportsDir, reportFile),
          downloadUrl: `/reports/${reportFile}`,
        };
      }
      return null;
    } catch (error) {
      logger.error('Failed to get report:', error);
      return null;
    }
  }

  /**
   * List all reports
   */
  async listReports(): Promise<ReportMetadata[]> {
    try {
      const files = await fs.readdir(this.reportsDir);
      const reports: ReportMetadata[] = [];

      for (const file of files) {
        const stats = await fs.stat(path.join(this.reportsDir, file));
        const type = file.endsWith('.pdf') ? 'pdf' :
                    file.endsWith('.json') ? 'json' :
                    file.endsWith('.xlsx') ? 'xlsx' : 'txt';

        // Extract ID from filename
        const matches = file.match(/_([a-f0-9-]+)\.[^.]+$/);
        const id = matches ? matches[1] : file;

        reports.push({
          id,
          name: file.replace(/_[a-f0-9-]+\.[^.]+$/, ''),
          description: 'Report file',
          type: type as any,
          size: stats.size,
          agent: 'Unknown',
          useCaseId: 'Unknown',
          createdAt: stats.birthtime,
          storagePath: path.join(this.reportsDir, file),
          downloadUrl: `/reports/${file}`,
        });
      }

      return reports.sort((a, b) => b.createdAt.getTime() - a.createdAt.getTime());
    } catch (error) {
      logger.error('Failed to list reports:', error);
      return [];
    }
  }

  /**
   * Delete a report
   */
  async deleteReport(reportId: string): Promise<boolean> {
    try {
      const files = await fs.readdir(this.reportsDir);
      const reportFile = files.find(f => f.includes(reportId));
      if (reportFile) {
        await fs.unlink(path.join(this.reportsDir, reportFile));
        try {
          await fs.unlink(path.join(this.publicReportsDir, reportFile));
        } catch (e) {
          // Public file might not exist
        }
        logger.info('Report deleted:', reportId);
        return true;
      }
      return false;
    } catch (error) {
      logger.error('Failed to delete report:', error);
      return false;
    }
  }

  /**
   * Helper method to format ReportContent as text
   */
  private formatReportContentAsText(content: ReportContent, metadata: any): string {
    const separator = '='.repeat(80);
    const subSeparator = '-'.repeat(80);
    
    let text = `${separator}\n`;
    text += `${content.title.toUpperCase()}\n`;
    text += `${separator}\n\n`;
    
    if (content.subtitle) {
      text += `${content.subtitle}\n\n`;
    }

    text += `Report Information:\n`;
    text += `${subSeparator}\n`;
    text += `Generated by: ${metadata.agent}\n`;
    text += `Use Case: ${metadata.useCaseId}\n`;
    text += `Date: ${new Date().toLocaleString()}\n`;
    text += `${subSeparator}\n\n`;

    for (const section of content.sections) {
      text += `${section.heading}\n`;
      text += `${'-'.repeat(section.heading.length)}\n\n`;

      if (section.type === 'text') {
        text += `${section.content}\n\n`;
      } else if (section.type === 'list') {
        const items = section.content as string[];
        for (const item of items) {
          text += `  • ${item}\n`;
        }
        text += '\n';
      } else if (section.type === 'table') {
        const tableData = section.content as any[];
        if (tableData.length > 0) {
          const headers = Object.keys(tableData[0]);
          const columnWidths = headers.map(h => 
            Math.max(h.length, ...tableData.map(row => String(row[h] || '').length))
          );
          
          // Headers
          text += '  ';
          headers.forEach((h, i) => {
            text += h.padEnd(columnWidths[i] + 2);
          });
          text += '\n  ';
          columnWidths.forEach(w => {
            text += '-'.repeat(w) + '  ';
          });
          text += '\n';
          
          // Rows
          for (const row of tableData) {
            text += '  ';
            headers.forEach((h, i) => {
              text += String(row[h] || '').padEnd(columnWidths[i] + 2);
            });
            text += '\n';
          }
          text += '\n';
        }
      } else if (section.type === 'json') {
        text += '```json\n';
        text += JSON.stringify(section.content, null, 2) + '\n';
        text += '```\n\n';
      }
    }

    text += `\n${separator}\n`;
    text += `End of Report\n`;
    text += `${separator}\n`;

    return text;
  }
}

export const reportService = new ReportService();