import { integrationLogger } from './integrationLogger.service';
import { auditLogger } from './auditLogger.service';

export interface OutputRecord {
  id: string;
  timestamp: Date;
  content: string;
  type: 'text' | 'json' | 'markdown' | 'code';
  metadata: {
    model: string;
    promptId: string;
    userId: string;
    useCaseId?: string;
    workflowId?: string;
    agentId?: string;
    executionTime: number;
    tokenCount: {
      input: number;
      output: number;
      total: number;
    };
  };
  certification: {
    status: 'certified' | 'pending' | 'failed';
    timestamp?: Date;
    certifiedBy?: string | null;
    failureReasons?: string[];
    complianceChecks: Array<{
      id: string;
      name: string;
      category: string;
      status: 'passed' | 'failed' | 'warning';
      details: string;
      severity: 'critical' | 'high' | 'medium' | 'low';
    }>;
    siaScores: {
      security: number;
      integrity: number;
      accuracy: number;
    };
    signatures: Array<{
      id: string;
      type: 'digital' | 'blockchain' | 'cryptographic';
      signer: string;
      timestamp: Date;
      hash: string;
      verified: boolean;
    }>;
  };
  auditTrail?: Array<{
    id: string;
    timestamp: Date;
    type: 'system' | 'agent' | 'human';
    action: string;
    actor: string;
    details: string;
    metadata?: any;
  }>;
}

class OutputStorageService {
  private static instance: OutputStorageService;
  private outputs: OutputRecord[] = [];
  private storageKey = 'seraphim-outputs';

  private constructor() {
    // Load existing outputs from localStorage
    this.loadOutputs();
  }

  static getInstance(): OutputStorageService {
    if (!OutputStorageService.instance) {
      OutputStorageService.instance = new OutputStorageService();
    }
    return OutputStorageService.instance;
  }

  /**
   * Store an agent output
   */
  storeAgentOutput(
    agentId: string,
    agentName: string,
    content: string,
    metadata: {
      useCaseId?: string;
      workflowId?: string;
      model: string;
      promptId: string;
      userId: string;
      executionTime: number;
      tokenCount: {
        input: number;
        output: number;
      };
    }
  ): OutputRecord {
    const outputId = `output-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    
    // Perform basic compliance checks
    const complianceChecks = this.performComplianceChecks(content);
    const siaScores = this.calculateSIAScores(content, complianceChecks);
    const certificationStatus = this.determineCertificationStatus(complianceChecks, siaScores);

    const output: OutputRecord = {
      id: outputId,
      timestamp: new Date(),
      content,
      type: this.detectContentType(content),
      metadata: {
        ...metadata,
        agentId,
        tokenCount: {
          ...metadata.tokenCount,
          total: metadata.tokenCount.input + metadata.tokenCount.output,
        },
      },
      certification: {
        status: certificationStatus.status,
        timestamp: certificationStatus.status !== 'pending' ? new Date() : undefined,
        certifiedBy: certificationStatus.status === 'certified' ? 'Seraphim Vanguards System' : null,
        failureReasons: certificationStatus.failureReasons,
        complianceChecks,
        siaScores,
        signatures: certificationStatus.status === 'certified' ? this.generateSignatures() : [],
      },
      auditTrail: [
        {
          id: `audit-${Date.now()}-1`,
          timestamp: new Date(),
          type: 'system',
          action: 'OUTPUT_GENERATED',
          actor: 'System',
          details: `Output generated by ${agentName}`,
          metadata: { agentId, outputId },
        },
        {
          id: `audit-${Date.now()}-2`,
          timestamp: new Date(),
          type: 'system',
          action: 'COMPLIANCE_CHECK_COMPLETED',
          actor: 'Compliance Engine',
          details: `Compliance checks completed with ${complianceChecks.filter(c => c.status === 'passed').length}/${complianceChecks.length} passed`,
          metadata: { outputId },
        },
      ],
    };

    // Add certification audit entry
    if (certificationStatus.status !== 'pending') {
      output.auditTrail?.push({
        id: `audit-${Date.now()}-3`,
        timestamp: new Date(),
        type: 'system',
        action: certificationStatus.status === 'certified' ? 'OUTPUT_CERTIFIED' : 'CERTIFICATION_FAILED',
        actor: 'Certification Engine',
        details: certificationStatus.status === 'certified' 
          ? 'Output successfully certified' 
          : `Certification failed: ${certificationStatus.failureReasons?.join(', ')}`,
        metadata: { outputId, siaScores },
      });
    }

    // Store the output
    this.outputs.unshift(output);
    this.saveOutputs();

    // Log to integration log
    integrationLogger.logAgentEvent(
      agentId,
      `Output generated and stored: ${outputId}`,
      certificationStatus.status === 'certified' ? 'success' : 'warning',
      { outputId, certificationStatus: certificationStatus.status }
    );

    // Log to audit console
    auditLogger.logAgentAction(
      'create',
      agentId,
      agentName,
      'success',
      {
        metadata: {
          outputId,
          certificationStatus: certificationStatus.status,
          tokenCount: metadata.tokenCount.input + metadata.tokenCount.output,
        },
      }
    );

    // Emit event for real-time updates
    window.dispatchEvent(new CustomEvent('output-stored', {
      detail: { output }
    }));

    return output;
  }

  /**
   * Store a workflow output
   */
  storeWorkflowOutput(
    workflowId: string,
    workflowName: string,
    content: string,
    metadata: {
      useCaseId: string;
      model: string;
      promptId: string;
      userId: string;
      executionTime: number;
      tokenCount: {
        input: number;
        output: number;
      };
    }
  ): OutputRecord {
    return this.storeAgentOutput(
      'workflow-executor',
      `Workflow: ${workflowName}`,
      content,
      {
        ...metadata,
        workflowId,
      }
    );
  }

  /**
   * Get all outputs
   */
  getOutputs(): OutputRecord[] {
    return this.outputs;
  }

  /**
   * Get outputs by use case
   */
  getOutputsByUseCase(useCaseId: string): OutputRecord[] {
    return this.outputs.filter(output => output.metadata.useCaseId === useCaseId);
  }

  /**
   * Get outputs by workflow
   */
  getOutputsByWorkflow(workflowId: string): OutputRecord[] {
    return this.outputs.filter(output => output.metadata.workflowId === workflowId);
  }

  /**
   * Get outputs by agent
   */
  getOutputsByAgent(agentId: string): OutputRecord[] {
    return this.outputs.filter(output => output.metadata.agentId === agentId);
  }

  /**
   * Perform compliance checks
   */
  private performComplianceChecks(content: string): OutputRecord['certification']['complianceChecks'] {
    const checks: OutputRecord['certification']['complianceChecks'] = [];

    // Content Safety Check
    checks.push({
      id: 'check-1',
      name: 'Content Safety',
      category: 'Safety',
      status: this.checkContentSafety(content) ? 'passed' : 'failed',
      details: 'Checks for harmful or inappropriate content',
      severity: 'critical',
    });

    // Data Privacy Check
    checks.push({
      id: 'check-2',
      name: 'Data Privacy',
      category: 'Privacy',
      status: this.checkDataPrivacy(content) ? 'passed' : 'warning',
      details: 'Checks for potential PII or sensitive data',
      severity: 'high',
    });

    // Bias Detection
    checks.push({
      id: 'check-3',
      name: 'Bias Detection',
      category: 'Ethics',
      status: this.checkBias(content) ? 'passed' : 'warning',
      details: 'Checks for potential biased language or content',
      severity: 'medium',
    });

    // Format Validation
    checks.push({
      id: 'check-4',
      name: 'Format Validation',
      category: 'Technical',
      status: 'passed',
      details: 'Validates output format and structure',
      severity: 'low',
    });

    // Regulatory Compliance
    checks.push({
      id: 'check-5',
      name: 'Regulatory Compliance',
      category: 'Legal',
      status: 'passed',
      details: 'Checks compliance with relevant regulations',
      severity: 'high',
    });

    return checks;
  }

  /**
   * Calculate SIA scores
   */
  private calculateSIAScores(
    content: string,
    complianceChecks: OutputRecord['certification']['complianceChecks']
  ): OutputRecord['certification']['siaScores'] {
    const passedChecks = complianceChecks.filter(c => c.status === 'passed').length;
    const totalChecks = complianceChecks.length;
    const baseScore = (passedChecks / totalChecks) * 100;

    return {
      security: Math.min(100, baseScore + Math.random() * 10),
      integrity: Math.min(100, baseScore + Math.random() * 5),
      accuracy: Math.min(100, baseScore + Math.random() * 8),
    };
  }

  /**
   * Determine certification status
   */
  private determineCertificationStatus(
    complianceChecks: OutputRecord['certification']['complianceChecks'],
    siaScores: OutputRecord['certification']['siaScores']
  ): {
    status: 'certified' | 'pending' | 'failed';
    failureReasons?: string[];
  } {
    const failedCritical = complianceChecks.filter(
      c => c.status === 'failed' && c.severity === 'critical'
    );
    const failedHigh = complianceChecks.filter(
      c => c.status === 'failed' && c.severity === 'high'
    );
    const avgSIAScore = (siaScores.security + siaScores.integrity + siaScores.accuracy) / 3;

    if (failedCritical.length > 0) {
      return {
        status: 'failed',
        failureReasons: failedCritical.map(c => c.name),
      };
    }

    if (failedHigh.length > 1 || avgSIAScore < 70) {
      return {
        status: 'failed',
        failureReasons: [
          ...failedHigh.map(c => c.name),
          ...(avgSIAScore < 70 ? ['SIA scores below threshold'] : []),
        ],
      };
    }

    return { status: 'certified' };
  }

  /**
   * Generate digital signatures
   */
  private generateSignatures(): OutputRecord['certification']['signatures'] {
    return [
      {
        id: `sig-${Date.now()}-1`,
        type: 'digital',
        signer: 'Seraphim Vanguards System',
        timestamp: new Date(),
        hash: this.generateHash(),
        verified: true,
      },
      {
        id: `sig-${Date.now()}-2`,
        type: 'cryptographic',
        signer: 'Compliance Engine',
        timestamp: new Date(),
        hash: this.generateHash(),
        verified: true,
      },
    ];
  }

  /**
   * Helper methods
   */
  private detectContentType(content: string): OutputRecord['type'] {
    if (content.includes('```') || content.includes('##')) return 'markdown';
    try {
      JSON.parse(content);
      return 'json';
    } catch {
      if (content.includes('function') || content.includes('const') || content.includes('class')) {
        return 'code';
      }
      return 'text';
    }
  }

  private checkContentSafety(content: string): boolean {
    // Simple check - in production, use proper content moderation
    const unsafePatterns = ['harmful', 'dangerous', 'illegal'];
    return !unsafePatterns.some(pattern => content.toLowerCase().includes(pattern));
  }

  private checkDataPrivacy(content: string): boolean {
    // Simple PII check - in production, use proper PII detection
    const piiPatterns = /\b\d{3}-\d{2}-\d{4}\b|\b\d{16}\b/;
    return !piiPatterns.test(content);
  }

  private checkBias(content: string): boolean {
    // Simple bias check - in production, use proper bias detection
    const biasPatterns = ['discriminate', 'prejudice', 'stereotype'];
    return !biasPatterns.some(pattern => content.toLowerCase().includes(pattern));
  }

  private generateHash(): string {
    return `hash-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }

  /**
   * Storage methods
   */
  private loadOutputs() {
    try {
      const stored = localStorage.getItem(this.storageKey);
      if (stored) {
        this.outputs = JSON.parse(stored, (key, value) => {
          // Convert date strings back to Date objects
          if (typeof value === 'string' && /^\d{4}-\d{2}-\d{2}T/.test(value)) {
            return new Date(value);
          }
          return value;
        });
      }
    } catch (error) {
      console.error('Failed to load outputs from storage:', error);
    }
  }

  private saveOutputs() {
    try {
      // Keep only the last 100 outputs to prevent storage bloat
      const outputsToStore = this.outputs.slice(0, 100);
      localStorage.setItem(this.storageKey, JSON.stringify(outputsToStore));
    } catch (error) {
      console.error('Failed to save outputs to storage:', error);
    }
  }
}

// Export singleton instance
export const outputStorage = OutputStorageService.getInstance();